module z1top # (
  // We are using a 125 MHz input clock for our design.
  // It is declared as a parameter so the testbench can override it if desired
  // This clock isn't used directly
  parameter SYSTEM_CLOCK_FREQ = 125_000_000,

  // CPU clock frequency in Hz.
  // This is generated by one of the Zynq's PLLs. The PLL must be configured
  // to generate this value.
  parameter CPU_CLOCK_FREQ = 50_000_000,

  // These are used for the button debouncer.
  // They are overridden in the testbench for faster runtime.
  parameter integer B_SAMPLE_COUNT_MAX = 0.0002 * SYSTEM_CLOCK_FREQ,
  parameter integer B_PULSE_COUNT_MAX = 0.03/0.0002,

  // I2S control signals.
  parameter integer LRCK_FREQ_HZ = 22050,
  parameter integer MCLK_TO_LRCK_RATIO = 128,
  parameter integer BIT_DEPTH = 24
) (
  input USER_CLK,             // 125 MHz clock.

    input RESET,
    input [2:0] BUTTONS,        // Momentary push-buttons.
    input [1:0] SWITCHES,       // Slide switches
    output [5:0] LEDS,          // Board LEDs.
//    output [7:0] PMOD_LEDS,
    output aud_sd,


  // UART connections
  input FPGA_SERIAL_RX,
  output FPGA_SERIAL_TX,

  // i2s Signals
  output MCLK,                // Master Clock.
  output LRCK,                // Left-right Clock.
  output SCLK,                // Serial Clock.
  output SDIN,                // Serial audio data output.

  // Primitive audio
  output AUDIO_PWM

  // More to come: HDMI, an AXI DRAM interface, ...
);

    // Remove these lines when implementing checkpoint 3.
//    assign MCLK = 1'b1;
//    assign LRCK = 1'b1;
//    assign SDIN = 1'b1;
//    assign SDIN = 1'b1;

    // Remove these lines when implementing checkpoint 2.
//    assign AUDIO_PWM = 1'b0;
    assign aud_sd = 1'b1;

    //// Clocking
    wire user_clk_g, cpu_clk, cpu_clk_g, cpu_clk_pll_lock;
    wire cpu_clk_pll_fb_out, cpu_clk_pll_fb_in;
        
    reg [31:0] counter;
    reg sig;
    wire [31:0] pc;
    always @(posedge cpu_clk_g) begin
      if (counter == CPU_CLOCK_FREQ - 1) begin
        counter <= 32'b0;
        sig <= ~sig;
      end
      else counter <= counter + 1;
    end
//    assign LEDS[5] = sig;
//    assign LEDS[4] = cpu_clk_pll_lock;
//    assign LEDS[3] = cpu_clk_g;
//    assign LEDS[2:0] = counter[26:24];
    
//    assign PMOD_LEDS[7:1] = pc[31:25];



  IBUFG user_clk_buf ( .I(USER_CLK), .O(user_clk_g) );
  BUFG  cpu_clk_buf  ( .I(cpu_clk),  .O(cpu_clk_g)  );
  BUFG  clkf_buf     (.I (cpu_clk_pll_fb_out), .O (cpu_clk_pll_fb_in));
  
  // Magical instantiation of a PLL on the Zynq chip. (If you're curious,
  // you can create one yourself with the Clocking Wizard IP.)
  PLLE2_ADV
  #(.BANDWIDTH            ("OPTIMIZED"),
  .COMPENSATION         ("BUF_IN"),  // Not "ZHOLD"
  .STARTUP_WAIT         ("FALSE"),
  .DIVCLK_DIVIDE        (5),
  .CLKFBOUT_MULT        (34),
  .CLKFBOUT_PHASE       (0.000),
  .CLKOUT0_DIVIDE       (17),
  .CLKOUT0_PHASE        (0.000),
  .CLKOUT0_DUTY_CYCLE   (0.500),
  .CLKIN1_PERIOD        (8.000))
  plle2_adv_inst
  // Output clocks
  (
  .CLKFBOUT            (cpu_clk_pll_fb_out),
  .CLKOUT0             (cpu_clk),
   // Input clock control
  .CLKFBIN             (cpu_clk_pll_fb_in),
  .CLKIN1              (user_clk_g),
  .CLKIN2              (1'b0),
   // Tied to always select the primary input clock
  .CLKINSEL            (1'b1),
  // Other control and status signals
  .LOCKED              (cpu_clk_pll_lock),
  .PWRDWN              (1'b0),
  .RST                 (1'b0));
      
  // -------------------------------------------------------------------------
  // User I/O, including resets
  // -------------------------------------------------------------------------

  // The global system reset is asserted when the RESET button is
  // pressed by the user or when the PLL isn't locked
  wire [2:0] clean_buttons;
  wire reset_button, reset;
  assign reset = reset_button || ~cpu_clk_pll_lock;

  button_parser #(
      .width(4),
      .sample_count_max(B_SAMPLE_COUNT_MAX),
      .pulse_count_max(B_PULSE_COUNT_MAX)
  ) b_parser (
      .clk(cpu_clk_g),
      .in({RESET, BUTTONS}),
      .out({reset_button, clean_buttons})
  );

  wire tone_output_enable;
  wire [23:0] tone_switch_period;
  // -------------------------------------------------------------------------
  // Tone generator
  // -------------------------------------------------------------------------
  tone_generator tony (
      .clk(cpu_clk_g),
      .rst(reset_button),
      .output_enable(tone_output_enable && BUTTONS[0]), // from CPU
      .tone_switch_period(tone_switch_period), // 24 bits from CPU
      .square_wave_out(AUDIO_PWM) // output
  );


  // -------------------------------------------------------------------------
  // I2S controller
  // -------------------------------------------------------------------------
  //
    
    wire [BIT_DEPTH-1:0] dout_to_pcm_data;
    wire pcm_data_ready_to_rd_en;
    wire async_fifo_empty;
    
    i2s_controller #(.BIT_DEPTH(BIT_DEPTH)
    ) connor (
        .sys_reset(reset),
        .sys_clk(cpu_clk_g),            // Source clock, from which others are derived
      
        .pcm_data(dout_to_pcm_data),
        .pcm_data_valid(!async_fifo_empty),
        .pcm_data_ready(pcm_data_ready_to_rd_en),
      
        // I2S control signals
        .mclk(MCLK),              // Master clock for the I2S chip
        .sclk(SCLK),
        .lrck(LRCK),              // Left-right clock, which determines which channel each audio datum is sent to.
        .sdin(SDIN)  
     );
  // -------------------------------------------------------------------------
 // async FIFO
 // -------------------------------------------------------------------------
 //  
 
    wire [BIT_DEPTH-1:0] async_fifo_din;
    wire async_fifo_wr_en;
    wire async_fifo_full;
    
    async_fifo #(.data_width(BIT_DEPTH)
    ) async_FIFO (
     .wr_clk(cpu_clk_g), 
     .rd_clk(SCLK),
     // Write side
     .wr_en(async_fifo_wr_en),
     .din(async_fifo_din),
     .full(async_fifo_full),
     // Read side
     .rd_en(pcm_data_ready_to_rd_en),
     .dout(dout_to_pcm_data),
     .empty(async_fifo_empty)
    );   
  
  
  // For the clock, use user_clk_g.

  // Your RISC-V 151 CPU
  Riscv151 #(
    .CPU_CLOCK_FREQ(CPU_CLOCK_FREQ),
    .BIT_DEPTH(BIT_DEPTH)
  ) CPU (
    .clk(cpu_clk_g),
    .rst(reset),

    .FPGA_SERIAL_RX(FPGA_SERIAL_RX),
    .FPGA_SERIAL_TX(FPGA_SERIAL_TX),

    // GPIO FIFO?
    .BUTTONS({reset_button, clean_buttons}),
    // GPIO switches?
    .SWITCHES(SWITCHES),
    // GPIO LEDS?
    .LEDS(LEDS),          // Board LEDs.
    .PMOD_LEDS(),

    // Tone generator hookups?
    .tone_output_enable(tone_output_enable),
    .tone_switch_period(tone_switch_period),
    // I2S/ASYNC FIFO hookups?
    .async_fifo_din(async_fifo_din),
    .async_fifo_wr_en(async_fifo_wr_en),
    .async_fifo_full(async_fifo_full)
  );
endmodule

