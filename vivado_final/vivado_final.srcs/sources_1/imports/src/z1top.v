module z1top # (
    // We are using a 125 MHz input clock for our design.
    // It is declared as a parameter so the testbench can override it if desired
    // This clock isn't used directly
    parameter SYSTEM_CLOCK_FREQ = 125_000_000,

    // CPU clock frequency in Hz.
    // This is generated by one of the Zynq's PLLs. The PLL must be configured
    // to generate this value.
    parameter CPU_CLOCK_FREQ = 50_000_000,

    // These are used for the button debouncer.
    // They are overridden in the testbench for faster runtime.
    parameter integer B_SAMPLE_COUNT_MAX = 0.0002 * SYSTEM_CLOCK_FREQ,
    parameter integer B_PULSE_COUNT_MAX = 0.03/0.0002
) (
    input USER_CLK,             // 125 MHz clock.

    input RESET,
    input [2:0] BUTTONS,        // Momentary push-buttons.
    input [1:0] SWITCHES,       // Slide switches
    output [5:0] LEDS,          // Board LEDs.

    // UART connections
    input FPGA_SERIAL_RX,
    output FPGA_SERIAL_TX,

    // I2S Signals
    output MCLK,                // Master Clock.
    output LRCK,                // Left-right Clock.
    output SCLK,                // Serial Clock.
    output SDIN,                // Serial audio data output.

    // Primitive audio
    output AUDIO_PWM

    // More to come: HDMI, an AXI DRAM interface, ...
);
    // Remove these lines when implementing checkpoint 3.
    assign MLCK = 1'b1;
    assign LRCK = 1'b1;
    assign SDIN = 1'b1;
    assign SDIN = 1'b1;

    // Remove these lines when implementing checkpoint 2.
    assign AUDIO_PWM = 1'b0;

    //// Clocking
    wire user_clk_g, cpu_clk, cpu_clk_g, cpu_clk_pll_lock;
    wire cpu_clk_pll_fb_out, cpu_clk_pll_fb_in;
        
    reg [31:0] counter;
    reg sig;
    always @(posedge cpu_clk_g) begin
      if (counter == CPU_CLOCK_FREQ - 1) begin
        counter <= 32'b0;
        sig <= ~sig;
      end
      else counter <= counter + 1;
    end
    assign LEDS[5] = sig;
    assign LEDS[4] = cpu_clk_pll_lock;
    assign LEDS[3] = cpu_clk_g;
    assign LEDS[2:0] = counter[26:24];

    //// Resets
    // The global system reset is asserted when the RESET button is
    // pressed by the user or when the PLL isn't locked
    wire [2:0] clean_buttons;
    wire reset_button, reset;
    assign reset = reset_button || ~cpu_clk_pll_lock;

    //// User IO
    button_parser #(
        .width(4),
        .sample_count_max(B_SAMPLE_COUNT_MAX),
        .pulse_count_max(B_PULSE_COUNT_MAX)
    ) b_parser (
        .clk(cpu_clk_g),
        .in({RESET, BUTTONS}),
        .out({reset_button, clean_buttons})
    );

    // The clocks need to be buffered before they can be used
    IBUFG user_clk_buf ( .I(USER_CLK), .O(user_clk_g) );
    BUFG  cpu_clk_buf  ( .I(cpu_clk),  .O(cpu_clk_g)  );
    BUFG  clkf_buf     (.I (cpu_clk_pll_fb_out), .O (cpu_clk_pll_fb_in));
    
    // Magical instantiation of a PLL on the Zynq chip. (If you're curious,
    // you can create one yourself with the Clocking Wizard IP.)
    PLLE2_ADV
    #(.BANDWIDTH            ("OPTIMIZED"),
    .COMPENSATION         ("ZHOLD"),
    .STARTUP_WAIT         ("FALSE"),
    .DIVCLK_DIVIDE        (5),
    .CLKFBOUT_MULT        (34),
    .CLKFBOUT_PHASE       (0.000),
    .CLKOUT0_DIVIDE       (17),
    .CLKOUT0_PHASE        (0.000),
    .CLKOUT0_DUTY_CYCLE   (0.500),
    .CLKIN1_PERIOD        (8.000))
    plle2_adv_inst
    // Output clocks
    (
    .CLKFBOUT            (cpu_clk_pll_fb_out),
    .CLKOUT0             (cpu_clk),
     // Input clock control
    .CLKFBIN             (cpu_clk_pll_fb_in),
    .CLKIN1              (user_clk_g),
    .CLKIN2              (1'b0),
     // Tied to always select the primary input clock
    .CLKINSEL            (1'b1),
    // Other control and status signals
    .LOCKED              (cpu_clk_pll_lock),
    .PWRDWN              (1'b0),
    .RST                 (1'b0));

    // Your RISC-V 151 CPU
    Riscv151 #(
        .CPU_CLOCK_FREQ(CPU_CLOCK_FREQ)
    ) CPU(
        .clk(cpu_clk_g),
        .rst(reset),
        .FPGA_SERIAL_RX(FPGA_SERIAL_RX),
        .FPGA_SERIAL_TX(FPGA_SERIAL_TX)
    );
endmodule
